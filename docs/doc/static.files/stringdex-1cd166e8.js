class RoaringBitmap{constructor(u8array){this.keys=[];this.cardinalities=[];this.containers=[];this.consumed_len_bytes=0;if(u8array===null||u8array.length===0){return this}if(u8array[0]<0x3a){const lspecial=u8array[0];let pspecial=1;for(let ispecial=0;ispecial<lspecial;ispecial+=1){const key=u8array[pspecial+2]|(u8array[pspecial+3]<<8);const value=u8array[pspecial]|(u8array[pspecial+1]<<8);let mid=this.getContainerId(key);let container;if(mid===-1){this.keys.push(key);container=new RoaringBitmapArray(0,new Uint8Array(2));mid=this.containers.length;this.containers.push(container);this.cardinalities.push(0)}else{container=this.containers[mid]}const cardinalityOld=this.cardinalities[mid];if(!(container instanceof RoaringBitmapArray)||container.array.byteLength<((cardinalityOld+1)*2)){const newBuf=new Uint8Array((cardinalityOld+1)*4);let idx=0;for(const cvalue of container.values()){newBuf[idx]=cvalue&0xFF;newBuf[idx+1]=(cvalue>>8)&0xFF;idx+=2}container=new RoaringBitmapArray(cardinalityOld+1,newBuf);this.containers[mid]=container}else{container.cardinality=cardinalityOld+1}container.array[cardinalityOld*2]=value&0xFF;container.array[(cardinalityOld*2)+1]=(value>>8)&0xFF;this.cardinalities[mid]=cardinalityOld+1;pspecial+=4}this.consumed_len_bytes=pspecial;return this}const has_runs=u8array[0]===0x3b;if(u8array[0]!==0x3a&&u8array[0]!==0x3b){throw new Error("not a roaring bitmap: "+u8array[0])}const size=has_runs?((u8array[2]|(u8array[3]<<8))+1):((u8array[4]|(u8array[5]<<8)|(u8array[6]<<16)|(u8array[7]<<24)));let i=has_runs?4:8;let is_run;if(has_runs){const is_run_len=Math.floor((size+7)/8);is_run=new Uint8Array(u8array.buffer,i+u8array.byteOffset,is_run_len);i+=is_run_len}else{is_run=new Uint8Array()}for(let j=0;j<size;++j){this.keys.push(u8array[i]|(u8array[i+1]<<8));i+=2;this.cardinalities.push((u8array[i]|(u8array[i+1]<<8))+1);i+=2}let offsets=null;if(!has_runs||this.keys.length>=4){offsets=[];for(let j=0;j<size;++j){offsets.push(u8array[i]|(u8array[i+1]<<8)|(u8array[i+2]<<16)|(u8array[i+3]<<24));i+=4}}for(let j=0;j<size;++j){if(offsets&&offsets[j]!==i){console.log(this.containers);throw new Error(`corrupt bitmap ${j}: ${i} / ${offsets[j]}`)}if(is_run[j>>3]&(1<<(j&0x7))){const runcount=(u8array[i]|(u8array[i+1]<<8));i+=2;this.containers.push(new RoaringBitmapRun(runcount,new Uint8Array(u8array.buffer,i+u8array.byteOffset,runcount*4),));i+=runcount*4}else if(this.cardinalities[j]>=4096){this.containers.push(new RoaringBitmapBits(new Uint8Array(u8array.buffer,i+u8array.byteOffset,8192,)));i+=8192}else{const end=this.cardinalities[j]*2;this.containers.push(new RoaringBitmapArray(this.cardinalities[j],new Uint8Array(u8array.buffer,i+u8array.byteOffset,end),));i+=end}}this.consumed_len_bytes=i}static makeSingleton(number){const result=new RoaringBitmap(null);result.cardinalities.push(1);result.keys.push(number>>16);result.containers.push(new RoaringBitmapArray(1,Uint8Array.from([number,number>>8]),));return result}static everything(){if(EVERYTHING_BITMAP.isEmpty()){let i=0;const l=1<<16;const everything_range=new RoaringBitmapRun(1,Uint8Array.of(0,0,0xff,0xff));while(i<l){EVERYTHING_BITMAP.keys.push(i);EVERYTHING_BITMAP.cardinalities.push(1<<16);EVERYTHING_BITMAP.containers.push(everything_range);i+=1}}return EVERYTHING_BITMAP}static empty(){return EMPTY_BITMAP}isEmpty(){return this.containers.length===0}union(that){if(this.isEmpty()){return that}if(that.isEmpty()){return this}let i=0;const il=this.keys.length;let j=0;const jl=that.keys.length;const result=new RoaringBitmap(null);while(i<il||j<jl){if(j>=jl||this.keys[i]<that.keys[j]){result.keys.push(this.keys[i]);result.containers.push(this.containers[i]);result.cardinalities.push(this.cardinalities[i]);i+=1}else if(i>=il||that.keys[j]<this.keys[i]){result.keys.push(that.keys[j]);result.containers.push(that.containers[j]);result.cardinalities.push(that.cardinalities[j]);j+=1}else{result.keys.push(this.keys[i]);const thisContainer=this.containers[i];const thatContainer=that.containers[j];if(thisContainer instanceof RoaringBitmapBits&&thatContainer instanceof RoaringBitmapBits){const resultArray=new Uint8Array(thisContainer.array.length>thatContainer.array.length?thisContainer.array.length:thatContainer.array.length,);let k=0;const kl=resultArray.length;let card=0;while(k<kl){const c=thisContainer.array[k]|thatContainer.array[k];resultArray[k]=c;card+=bitCount(c);k+=1}result.containers.push(new RoaringBitmapBits(resultArray));result.cardinalities.push(card)}else{const thisValues=thisContainer.values();const thatValues=thatContainer.values();let thisResult=thisValues.next();let thatResult=thatValues.next();const resultValues=[];while(!thatResult.done||!thisResult.done){const thisValue=thisResult.value;const thatValue=thatResult.value;if(thatResult.done||thisValue<thatValue){resultValues.push(thisValue);thisResult=thisValues.next()}else if(thisResult.done||thatValue<thisValue){resultValues.push(thatValue);thatResult=thatValues.next()}else{resultValues.push(thisValue);thisResult=thisValues.next();thatResult=thatValues.next()}}const resultArray=new Uint8Array(resultValues.length*2);let k=0;for(const value of resultValues){resultArray[k]=value&0xFF;resultArray[k+1]=(value>>8)&0xFF;k+=2}result.containers.push(new RoaringBitmapArray(resultValues.length,resultArray,));result.cardinalities.push(resultValues.length)}i+=1;j+=1}}return result}intersection(that){if(this.isEmpty()||that.isEmpty()){return EMPTY_BITMAP}let i=0;const il=this.keys.length;let j=0;const jl=that.keys.length;const result=new RoaringBitmap(null);while(i<il&&j<jl){if(this.keys[i]<that.keys[j]){i+=1}else if(that.keys[j]<this.keys[i]){j+=1}else{const thisContainer=this.containers[i];const thatContainer=that.containers[j];if(thisContainer instanceof RoaringBitmapBits&&thatContainer instanceof RoaringBitmapBits){const resultArray=new Uint8Array(thisContainer.array.length>thatContainer.array.length?thisContainer.array.length:thatContainer.array.length,);const k=0;const kl=resultArray.length;let card=0;while(k<kl){const c=thisContainer.array[k]&thatContainer.array[k];resultArray[k]=c;card+=bitCount(c)}if(card!==0){result.keys.push(this.keys[i]);result.containers.push(new RoaringBitmapBits(resultArray));result.cardinalities.push(card)}}else{const thisValues=thisContainer.values();const thatValues=thatContainer.values();let thisValue=thisValues.next();let thatValue=thatValues.next();const resultValues=[];while(!thatValue.done&&!thisValue.done){if(thisValue.value<thatValue.value){thisValue=thisValues.next()}else if(thatValue.value<thisValue.value){thatValue=thatValues.next()}else{resultValues.push(thisValue.value);thisValue=thisValues.next();thatValue=thatValues.next()}}if(resultValues.length!==0){const resultArray=new Uint8Array(resultValues.length*2);let k=0;for(const value of resultValues){resultArray[k]=value&0xFF;resultArray[k+1]=(value>>8)&0xFF;k+=2}result.keys.push(this.keys[i]);result.containers.push(new RoaringBitmapArray(resultValues.length,resultArray,));result.cardinalities.push(resultValues.length)}}i+=1;j+=1}}return result}contains(keyvalue){const key=keyvalue>>16;const value=keyvalue&0xFFFF;const mid=this.getContainerId(key);return mid===-1?false:this.containers[mid].contains(value)}getContainerId(key){let left=0;let right=this.keys.length-1;while(left<=right){const mid=Math.floor((left+right)/2);const x=this.keys[mid];if(x<key){left=mid+1}else if(x>key){right=mid-1}else{return mid}}return-1}*entries(){for(const i in this.containers){if(!Object.prototype.hasOwnProperty.call(this.containers,i)){continue}const key=this.keys[i];for(const value of this.containers[i].values()){yield(key<<16)|value}}}first(){for(const entry of this.entries()){return entry}return null}cardinality(){let result=0;for(const card of this.cardinalities){result+=card}return result}}class RoaringBitmapRun{constructor(runcount,array){this.runcount=runcount;this.array=array}contains(value){let left=0;let right=this.runcount-1;while(left<=right){const mid=Math.floor((left+right)/2);const i=mid*4;const start=this.array[i]|(this.array[i+1]<<8);const lenm1=this.array[i+2]|(this.array[i+3]<<8);if((start+lenm1)<value){left=mid+1}else if(start>value){right=mid-1}else{return true}}return false}*values(){let i=0;while(i<this.runcount){const start=this.array[i*4]|(this.array[(i*4)+1]<<8);const lenm1=this.array[(i*4)+2]|(this.array[(i*4)+3]<<8);let value=start;let j=0;while(j<=lenm1){yield value;value+=1;j+=1}i+=1}}}class RoaringBitmapArray{constructor(cardinality,array){this.cardinality=cardinality;this.array=array}contains(value){let left=0;let right=this.cardinality-1;while(left<=right){const mid=Math.floor((left+right)/2);const i=mid*2;const x=this.array[i]|(this.array[i+1]<<8);if(x<value){left=mid+1}else if(x>value){right=mid-1}else{return true}}return false}*values(){let i=0;const l=this.cardinality*2;while(i<l){yield this.array[i]|(this.array[i+1]<<8);i+=2}}}class RoaringBitmapBits{constructor(array){this.array=array}contains(value){return!!(this.array[value>>3]&(1<<(value&7)))}*values(){let i=0;const l=this.array.length<<3;while(i<l){if(this.contains(i)){yield i}i+=1}}}const EMPTY_BITMAP=new RoaringBitmap(null);EMPTY_BITMAP.consumed_len_bytes=0;const EMPTY_BITMAP1=new RoaringBitmap(null);EMPTY_BITMAP1.consumed_len_bytes=1;const EVERYTHING_BITMAP=new RoaringBitmap(null);function bitCount(n){n=(~~n)-((n>>1)&0x55555555);n=(n&0x33333333)+((n>>2)&0x33333333);return((n+(n>>4)&0xF0F0F0F)*0x1010101)>>24}function loadDatabase(hooks){const callbacks={rr_:function(data){const dataObj=JSON.parse(data);for(const colName of Object.keys(dataObj)){if(Object.hasOwn(dataObj[colName],"I")){registry.searchTreeRoots.set(colName,makeSearchTreeFromBase64(dataObj[colName].I)[1],)}if(Object.hasOwn(dataObj[colName],"N")){const counts=[];const countsstring=dataObj[colName]["N"];let i=0;let l=countsstring.length;while(i<l){let n=0;let c=countsstring.charCodeAt(i);while(c<96){n=(n<<4)|(c&0xF);i+=1;c=countsstring.charCodeAt(i)}n=(n<<4)|(c&0xF);counts.push(n);i+=1}const hashes=[];const hashbytes=makeUint8ArrayFromBase64(dataObj[colName]["H"]);i=0;l=hashbytes.length;while(i<l){hashes.push((BigInt(hashbytes[i])<<40n)|(BigInt(hashbytes[i+1])<<32n)|(BigInt(hashbytes[i+2])<<24n)|(BigInt(hashbytes[i+3])<<16n)|(BigInt(hashbytes[i+4])<<8n)|BigInt(hashbytes[i+5]),);i+=6}registry.dataColumns.set(colName,new DataColumn(counts,hashes,new RoaringBitmap(makeUint8ArrayFromBase64(dataObj[colName]["E"])),colName,))}}const cb=registry.searchTreeRootCallback;if(cb){cb(null,new Database(registry.searchTreeRoots,registry.dataColumns))}},err_rr_:function(err){const cb=registry.searchTreeRootCallback;if(cb){cb(err,null)}},rd_:function(dataString){const l=dataString.length;const data=new Uint8Array(l);for(let i=0;i<l;++i){data[i]=dataString.charCodeAt(i)}loadColumnFromBytes(data)},err_rd_:function(filename,err){const hash=BigInt("0x"+filename);const cb=registry.dataColumnLoadPromiseCallbacks.get(hash);if(cb){cb(err,null)}},rb_:function(dataString64){loadColumnFromBytes(makeUint8ArrayFromBase64(dataString64))},err_rb_:function(filename,err){const hash=BigInt("0x"+filename);const cb=registry.dataColumnLoadPromiseCallbacks.get(hash);if(cb){cb(err,null)}},rn_:function(inputBase64){const[hash,tree]=makeSearchTreeFromBase64(inputBase64);const hashBigInt=((BigInt(hash[0])<<40n)|(BigInt(hash[1])<<32n)|(BigInt(hash[2])<<24n)|(BigInt(hash[3])<<16n)|(BigInt(hash[4])<<8n)|BigInt(hash[5]));const cb=registry.searchTreeLoadPromiseCallbacks.get(hashBigInt);if(cb){cb(null,tree);registry.searchTreeLoadPromiseCallbacks.delete(hashBigInt)}},err_rn_:function(filename,err){const hash=BigInt("0x"+filename);const cb=registry.searchTreeLoadPromiseCallbacks.get(hash);if(cb){cb(err,null)}},};const registry={searchTreeLoadPromiseCallbacks:new Map(),dataColumnLoadPromiseCallbacks:new Map(),searchTreeRoots:new Map(),dataColumns:new Map(),searchTreeLoadByHash:function(hash){if(hash&0x0000800000000000n){const isWhole=Boolean(hash&0x0000400000000000n);const leaves=RoaringBitmap.makeSingleton(Number(hash&0xffffffffn));const data=(hash&0x0000010000000000n)!==0n?Uint8Array.of(Number(hash>>32n)&0xff):EMPTY_UINT8;return Promise.resolve(new SearchTree(EMPTY_UINT8,EMPTY_UINT8,EMPTY_UINT8,EMPTY_UINT8,data,isWhole?leaves:EMPTY_BITMAP,isWhole?EMPTY_BITMAP:leaves,))}else{const hashHex=bigUint64ToShortHex(hash);return new Promise((resolve,reject)=>{const cb=registry.searchTreeLoadPromiseCallbacks.get(hash);if(cb){registry.searchTreeLoadPromiseCallbacks.set(hash,(err,data)=>{cb(err,data);if(data){resolve(data)}else{reject(err)}})}else{registry.searchTreeLoadPromiseCallbacks.set(hash,(err,data)=>{if(data){resolve(data)}else{reject(err)}})}hooks.loadTreeByHash(hashHex)})}},dataLoadByNameAndHash:function(name,hash){const hashHex=bigUint64ToShortHex(hash);return new Promise((resolve,reject)=>{const cb=registry.dataColumnLoadPromiseCallbacks.get(hash);if(cb){registry.dataColumnLoadPromiseCallbacks.set(hash,(err,data)=>{cb(err,data);if(data){resolve(data)}else{reject(err)}})}else{registry.dataColumnLoadPromiseCallbacks.set(hash,(err,data)=>{if(data){resolve(data)}else{reject(err)}})}hooks.loadDataByNameAndHash(name,hashHex)})},};class SearchTreeBranches{constructor(keys,hashes){this.keys=keys;this.hashes=hashes;this.subtrees=[];const length=keys.length;for(let i=0;i<length;++i){this.subtrees.push(null)}}*entries(){let i=0;const l=this.keys.length;while(i<l){yield[this.keys[i],this.subtrees[i]];i+=1}}getIndex(k){let i=1;while(i<this.keys.length){if(this.keys[i-1]>=this.keys[i]){throw new Error("HERE")}i+=1}let left=0;let right=this.keys.length-1;while(left<=right){const mid=Math.floor((left+right)/2);if(this.keys[mid]<k){left=mid+1}else if(this.keys[mid]>k){right=mid-1}else{return mid}}return-1}getHash(i){return new Uint8Array(this.hashes.buffer,this.hashes.byteOffset+(i*6),6,)}getHashBigInt(i){const hash=this.getHash(i);return(BigInt(hash[5])|(BigInt(hash[4])<<8n)|(BigInt(hash[3])<<16n)|(BigInt(hash[2])<<24n)|(BigInt(hash[1])<<32n)|(BigInt(hash[0])<<40n))}}class SearchTree{constructor(might_have_prefix_branch_keys,might_have_prefix_branch_hashes,suffix_only_branch_keys,suffix_only_branch_hashes,data,leaves_whole,leaves_suffix,){this.might_have_prefix_branches=new SearchTreeBranches(might_have_prefix_branch_keys,might_have_prefix_branch_hashes,);if(suffix_only_branch_keys.length===0){this.branches=this.might_have_prefix_branches}else if(might_have_prefix_branch_keys.length===0){this.branches=new SearchTreeBranches(suffix_only_branch_keys,suffix_only_branch_hashes,)}else{const total_length=might_have_prefix_branch_keys.length+suffix_only_branch_keys.length;const keys=new Uint8Array(total_length);const hashes=new Uint8Array(total_length*6);let mhpi=0;const mhpl=might_have_prefix_branch_keys.length;const sol=suffix_only_branch_keys.length;let soi=0;let i=0;while(i<total_length){if(soi>=sol||(mhpi<mhpl&&might_have_prefix_branch_keys[mhpi]<suffix_only_branch_keys[soi])){keys[i]=might_have_prefix_branch_keys[mhpi];hashes.set(might_have_prefix_branch_hashes.subarray(mhpi*6,(mhpi+1)*6,),i*6);mhpi+=1}else{keys[i]=suffix_only_branch_keys[soi];hashes.set(suffix_only_branch_hashes.subarray(soi*6,(soi+1)*6,),i*6);soi+=1}i+=1}this.branches=new SearchTreeBranches(keys,hashes,)}this.data=data;this.leaves_suffix=leaves_suffix;this.leaves_whole=leaves_whole}trie(){return new Trie(this,0)}async search(name){if(typeof name==="string"){const utf8encoder=new TextEncoder();name=utf8encoder.encode(name)}let trie=this.trie();for(const datum of name){const newTrie=trie.child(datum);if(newTrie){trie=await newTrie}else{return null}}return trie}async*searchLev(name){if(typeof name==="string"){const utf8encoder=new TextEncoder();name=utf8encoder.encode(name)}const w=name.length;const levParams=w>=6?new Lev2TParametricDescription(w):new Lev1TParametricDescription(w);const stack=[[Promise.resolve(this.trie()),0]];const n=levParams.n;while(stack.length!==0){const[triePromise,levState]=stack.pop();const trie=await triePromise;for(const byte of trie.keysExcludeSuffixOnly()){const levPos=levParams.getPosition(levState);const vector=levParams.getVector(name,byte,levPos,Math.min(w,levPos+(2*n)+1),);const newLevState=levParams.transition(levState,levPos,vector,);if(newLevState>=0){const child=trie.child(byte);if(child){stack.push([child,newLevState]);if(levParams.isAccept(newLevState)){yield child}}}}}}}class Trie{constructor(tree,offset){this.tree=tree;this.offset=offset}matches(){if(this.offset===this.tree.data.length){return this.tree.leaves_whole}else{return EMPTY_BITMAP}}async*substringMatches(){let layer=[Promise.resolve(this.tree)];while(layer.length){const current_layer=layer;layer=[];for await(const tree of current_layer){yield tree.leaves_whole.union(tree.leaves_suffix)}const subnodes=new Map();for await(const node of current_layer){const branches=node.branches;const l=branches.subtrees.length;for(let i=0;i<l;++i){const subtree=branches.subtrees[i];if(subtree){layer.push(subtree)}else if(subtree===null){const byte=branches.keys[i];const newnode=branches.getHashBigInt(i);if(!newnode){console.log(this);throw new Error(`malformed tree; no hash for key ${byte}`)}else{let subnode_list=subnodes.get(newnode);if(!subnode_list){subnode_list=[[byte,node]];subnodes.set(newnode,subnode_list)}else{subnode_list.push([byte,node])}}}else{throw new Error(`malformed tree; index ${i} does not exist`)}}}for(const[newnode,subnode_list]of subnodes){const res=registry.searchTreeLoadByHash(newnode);for(const[byte,node]of subnode_list){const branches=node.branches;const might_have_prefix_branches=node.might_have_prefix_branches;const i=branches.getIndex(byte);branches.subtrees[i]=res;const mhpI=might_have_prefix_branches.getIndex(byte);if(mhpI!==-1){might_have_prefix_branches.subtrees[mhpI]=res}}layer.push(res)}}}async*prefixMatches(){let layer=[Promise.resolve(this.tree)];while(layer.length){const current_layer=layer;layer=[];for await(const tree of current_layer){yield tree.leaves_whole}const subnodes=new Map();for await(const node of current_layer){const mhp_branches=node.might_have_prefix_branches;const l=mhp_branches.subtrees.length;for(let i=0;i<l;++i){const subtree=mhp_branches.subtrees[i];if(subtree){layer.push(subtree)}else if(subtree===null){const byte=mhp_branches.keys[i];const newnode=mhp_branches.getHashBigInt(i);if(!newnode){console.log(this);throw new Error(`malformed tree; no hash for key ${byte}`)}else{let subnode_list=subnodes.get(newnode);if(!subnode_list){subnode_list=[[byte,node]];subnodes.set(newnode,subnode_list)}else{subnode_list.push([byte,node])}}}else{throw new Error(`malformed tree; index ${i} does not exist`)}}}for(const[newnode,subnode_list]of subnodes){const res=registry.searchTreeLoadByHash(newnode);for(const[byte,node]of subnode_list){const mhp_branches=node.might_have_prefix_branches;const i=mhp_branches.getIndex(byte);mhp_branches.subtrees[i]=res;const branches=node.branches;const bi=branches.getIndex(byte);mhp_branches.subtrees[bi]=res}layer.push(res)}}}keys(){const data=this.tree.data;if(this.offset===data.length){return this.tree.branches.keys}else{return Uint8Array.of(data[this.offset])}}children(){const data=this.tree.data;if(this.offset===data.length){const nodes=[];let i=0;for(const[k,v]of this.tree.branches.entries()){let node;if(v){node=v}else{const newnode=this.tree.branches.getHashBigInt(i);if(!newnode){throw new Error(`malformed tree; no hash for key ${k}: ${newnode} \
                                ${this.tree.branches.hashes} ${this.tree.branches.keys}`)}node=registry.searchTreeLoadByHash(newnode);this.tree.branches.subtrees[i]=node;const mhpI=this.tree.might_have_prefix_branches.getIndex(k);if(mhpI!==-1){this.tree.might_have_prefix_branches.subtrees[mhpI]=node}}nodes.push([k,node.then(node=>node.trie())]);i+=1}return nodes}else{const codePoint=data[this.offset];const trie=new Trie(this.tree,this.offset+1);return[[codePoint,Promise.resolve(trie)]]}}keysExcludeSuffixOnly(){const data=this.tree.data;if(this.offset===data.length){return this.tree.might_have_prefix_branches.keys}else{return Uint8Array.of(data[this.offset])}}childrenExcludeSuffixOnly(){const data=this.tree.data;if(this.offset===data.length){const nodes=[];let i=0;for(const[k,v]of this.tree.might_have_prefix_branches.entries()){let node;if(v){node=v}else{const newnode=this.tree.might_have_prefix_branches.getHashBigInt(i);if(!newnode){throw new Error(`malformed tree; no hash for key ${k}`)}node=registry.searchTreeLoadByHash(newnode);this.tree.might_have_prefix_branches.subtrees[i]=node;this.tree.branches.subtrees[this.tree.branches.getIndex(k)]=node}nodes.push([k,node.then(node=>node.trie())]);i+=1}return nodes}else{const codePoint=data[this.offset];const trie=new Trie(this.tree,this.offset+1);return[[codePoint,Promise.resolve(trie)]]}}child(byte){if(this.offset===this.tree.data.length){const i=this.tree.branches.getIndex(byte);if(i!==-1){let branch=this.tree.branches.subtrees[i];if(branch===null){const newnode=this.tree.branches.getHashBigInt(i);if(!newnode){throw new Error(`malformed tree; no hash for key ${byte}`)}branch=registry.searchTreeLoadByHash(newnode);this.tree.branches.subtrees[i]=branch;const mhpI=this.tree.might_have_prefix_branches.getIndex(byte);if(mhpI!==-1){this.tree.might_have_prefix_branches.subtrees[mhpI]=branch}}return branch.then(branch=>branch.trie())}}else if(this.tree.data[this.offset]===byte){return Promise.resolve(new Trie(this.tree,this.offset+1))}return null}}const EMPTY_UINT8=new Uint8Array();class DataColumn{constructor(counts,hashes,emptyset,name){this.hashes=hashes;this.emptyset=emptyset;this.name=name;this.buckets=[];this.bucket_keys=[];const l=counts.length;let k=0;for(let i=0;i<l;++i){const count=counts[i];const start=k;for(let j=0;j<count;++j){if(emptyset.contains(k)){j-=1}k+=1}const end=k;const bucket={hash:hashes[i],data:null,end,count};this.buckets.push(bucket);this.bucket_keys.push(start)}}isEmpty(id){return this.emptyset.contains(id)}async at(id){if(this.emptyset.contains(id)){return Promise.resolve(EMPTY_UINT8)}else{let idx=-1;while(this.bucket_keys[idx+1]<=id){idx+=1}if(idx===-1||idx>=this.bucket_keys.length){return Promise.resolve(undefined)}else{const start=this.bucket_keys[idx];const{hash,end}=this.buckets[idx];let data=this.buckets[idx].data;if(data===null){const dataSansEmptyset=await registry.dataLoadByNameAndHash(this.name,hash,);const dataWithEmptyset=[];let pos=start;let i=0;while(pos<end){if(this.emptyset.contains(pos)){dataWithEmptyset.push(EMPTY_UINT8)}else{dataWithEmptyset.push(dataSansEmptyset[i]);i+=1}pos+=1}data=Promise.resolve(dataWithEmptyset);this.buckets[idx].data=data}return(await data)[id-start]}}}}class Database{constructor(searchTreeRoots,dataColumns){this.searchTreeRoots=searchTreeRoots;this.dataColumns=dataColumns}getIndex(colname){return this.searchTreeRoots.get(colname)}getData(colname){return this.dataColumns.get(colname)}}function loadColumnFromBytes(data){const hashBuf=Uint8Array.of(0,0,0,0,0,0,0,0);const hashView=new DataView(hashBuf.buffer);siphashOfBytes(data,0,0,0,0,hashBuf);const hash=hashView.getBigUint64(0,false)&0x0000FFFFFFFFFFFFn;const cb=registry.dataColumnLoadPromiseCallbacks.get(hash);if(cb){const backrefs=[];const result=[];let i=0;const l=data.length;while(i<l){let c=data[i];if(c>=48&&c<=63){result.push(backrefs[c-48]);i+=1}else{let n=0;while(c<96){n=(n<<4)|(c&0xF);i+=1;c=data[i]}n=(n<<4)|(c&0xF);i+=1;const item=data.slice(i,i+n);result.push(item);i+=n;backrefs.unshift(item);if(backrefs.length>16){backrefs.pop()}}}cb(null,result)}}function makeSearchTreeFromBase64(inputBase64){const input=makeUint8ArrayFromBase64(inputBase64);let i=0;const l=input.length;const stash=new Map();const hash=Uint8Array.of(0,0,0,0,0,0,0,0);const truncatedHash=new Uint8Array(hash.buffer,2,6);const history=[];let canonical=EMPTY_UINT8;let tree=new SearchTree(EMPTY_UINT8,EMPTY_UINT8,EMPTY_UINT8,EMPTY_UINT8,EMPTY_UINT8,EMPTY_BITMAP,EMPTY_BITMAP,);while(i<l){const start=i;if(input[i]>=0x80){const compression_tag=input[i];const all_children_are_compressed=compression_tag===0x80;i+=1;const dlen=input[i];i+=1;const data=new Uint8Array(input.buffer,i+input.byteOffset,dlen);i+=dlen;const cplen_=input[i];let cplen=input[i];i+=1;const cslen_=input[i];let cslen=input[i];i+=1;if(cplen===0xff&&cslen===0xff){cplen=0x100;cslen=0}let j=0;const cpoff=i;while(j<cplen){i+=all_children_are_compressed||((0x80>>(j+1))&compression_tag)!==0?1:6;j+=1}j=0;const csoff=i;while(j<cslen){i+=all_children_are_compressed||((0x80>>(cplen+j+1))&compression_tag)!==0?1:6;j+=1}const cpbranches=new Uint8Array(input.buffer,i+input.byteOffset,cplen);i+=cplen;const csbranches=new Uint8Array(input.buffer,i+input.byteOffset,cslen);i+=cslen;let whole;let suffix;if(input[i]===0xff){whole=EMPTY_BITMAP;suffix=EMPTY_BITMAP1;i+=1}else{whole=new RoaringBitmap(new Uint8Array(input.buffer,i+input.byteOffset));i+=whole.consumed_len_bytes;suffix=new RoaringBitmap(new Uint8Array(input.buffer,i+input.byteOffset));i+=suffix.consumed_len_bytes}const cphashes=new Uint8Array(cplen*6);j=0;let off_i=0;while(j<cplen){const is_compressed=all_children_are_compressed||((0x80>>(j+1))&compression_tag)!==0;cphashes.set(is_compressed?history[history.length-input[cpoff+off_i]-1]:input.subarray(cpoff+off_i,cpoff+off_i+6),j*6,);j+=1;off_i+=is_compressed?1:6}const cshashes=new Uint8Array(cslen*6);j=0;off_i=0;while(j<cslen){const is_compressed=all_children_are_compressed||((0x80>>(cplen+j+1))&compression_tag)!==0;cshashes.set(is_compressed?history[history.length-input[csoff+off_i]-1]:input.subarray(csoff+off_i,csoff+off_i+6),j*6,);j+=1;off_i+=is_compressed?1:6}tree=new SearchTree(cpbranches,cphashes,csbranches,cshashes,data,whole,suffix,);const clen=(4+dlen+((cplen+cslen)*6)+(cplen+cslen)+whole.consumed_len_bytes+suffix.consumed_len_bytes);if(canonical.length<clen){canonical=new Uint8Array(clen)}let ci=0;canonical[ci]=0;ci+=1;canonical[ci]=dlen;ci+=1;canonical.set(data,ci);ci+=dlen;canonical[ci]=cplen_;ci+=1;canonical[ci]=cslen_;ci+=1;canonical.set(cphashes,ci);ci+=cplen*6;canonical.set(cshashes,ci);ci+=cslen*6;canonical.set(cpbranches,ci);ci+=cplen;canonical.set(csbranches,ci);ci+=cslen;canonical.set(input.subarray(i-whole.consumed_len_bytes-suffix.consumed_len_bytes,i,),ci);siphashOfBytes(canonical.subarray(0,clen),0,0,0,0,hash);hash[2]&=0x7f}else{const dlen=(input[i]<<8)|input[i+1];i+=2;const data=new Uint8Array(input.buffer,i+input.byteOffset,dlen);i+=dlen;let cplen=input[i];i+=1;let cslen=input[i];i+=1;if(cplen===0xff&&cslen===0xff){cplen=0x100;cslen=0}const cphashes=new Uint8Array(input.buffer,i+input.byteOffset,cplen*6);i+=cplen*6;const cshashes=new Uint8Array(input.buffer,i+input.byteOffset,cslen*6);i+=cslen*6;const cpbranches=new Uint8Array(input.buffer,i+input.byteOffset,cplen);i+=cplen;const csbranches=new Uint8Array(input.buffer,i+input.byteOffset,cslen);i+=cslen;let whole;let suffix;if(input[i]===0xff){whole=EMPTY_BITMAP;suffix=EMPTY_BITMAP;i+=1}else{whole=new RoaringBitmap(new Uint8Array(input.buffer,i+input.byteOffset));i+=whole.consumed_len_bytes;suffix=new RoaringBitmap(new Uint8Array(input.buffer,i+input.byteOffset));i+=suffix.consumed_len_bytes}siphashOfBytes(new Uint8Array(input.buffer,start+input.byteOffset,i-start,),0,0,0,0,hash);hash[2]&=0x7f;tree=new SearchTree(cpbranches,cphashes,csbranches,cshashes,data,whole,suffix,)}history.push(truncatedHash.slice());const tree_branch_hashes=tree.branches.hashes;const tree_branch_subtrees=tree.branches.subtrees;const tree_mhp_branch_hashes=tree.might_have_prefix_branches.hashes;const tree_mhp_branch_subtrees=tree.might_have_prefix_branches.subtrees;let j=0;let lb=tree.branches.keys.length;while(j<lb){let k=0;const hashKey=tree_branch_hashes[(j*6)+5]|(tree_branch_hashes[(j*6)+4]<<8);let part=stash.get(hashKey);if(!part){part=[new Uint8Array(48),[]];stash.set(hashKey,part)}const[stashHashes,stashTrees]=part;const m=stashTrees.length;while(k<m){if(tree_branch_hashes[j*6]===stashHashes[k*6]&&tree_branch_hashes[(j*6)+1]===stashHashes[(k*6)+1]&&tree_branch_hashes[(j*6)+2]===stashHashes[(k*6)+2]&&tree_branch_hashes[(j*6)+3]===stashHashes[(k*6)+3]){tree_branch_subtrees[j]=Promise.resolve(stashTrees[k]);break}k+=1}j+=1}j=0;lb=tree.might_have_prefix_branches.keys.length;while(j<lb){let k=0;const hashKey=tree_mhp_branch_hashes[(j*6)+5]|(tree_mhp_branch_hashes[(j*6)+4]<<8);let part=stash.get(hashKey);if(!part){part=[new Uint8Array(6),[]];stash.set(hashKey,part)}const[stashHashes,stashTrees]=part;const m=stashTrees.length;while(k<m){if(tree_mhp_branch_hashes[j*6]===stashHashes[k*6]&&tree_mhp_branch_hashes[(j*6)+1]===stashHashes[(k*6)+1]&&tree_mhp_branch_hashes[(j*6)+2]===stashHashes[(k*6)+2]&&tree_mhp_branch_hashes[(j*6)+3]===stashHashes[(k*6)+3]){tree_mhp_branch_subtrees[j]=Promise.resolve(stashTrees[k]);break}k+=1}j+=1}if(i!==l){const hashKey=truncatedHash[5]|(truncatedHash[4]<<8);let part=stash.get(hashKey);if(!part){part=[new Uint8Array(6),[]];stash.set(hashKey,part)}let stashHashes=part[0];const stashTrees=part[1];if((stashTrees.length*6)+6>=stashHashes.length){const newStashHashes=new Uint8Array(stashHashes.length*2);newStashHashes.set(stashHashes,0);stash.set(hashKey,[newStashHashes,stashTrees]);stashHashes=newStashHashes}stashHashes.set(truncatedHash,stashTrees.length*6);stashTrees.push(tree)}}return[truncatedHash,tree]}return new Promise((resolve,reject)=>{registry.searchTreeRootCallback=(error,data)=>{if(data){resolve(data)}else{reject(error)}};hooks.loadRoot(callbacks)})}if(typeof window!=="undefined"){window.Stringdex={loadDatabase,};window.RoaringBitmap=RoaringBitmap;if(window.StringdexOnload){window.StringdexOnload.forEach(cb=>cb(window.Stringdex))}}else{module.exports.Stringdex={loadDatabase,};module.exports.RoaringBitmap=RoaringBitmap}const makeUint8ArrayFromBase64=Uint8Array.fromBase64?Uint8Array.fromBase64:(string=>{const bytes_as_string=atob(string);const l=bytes_as_string.length;const bytes=new Uint8Array(l);for(let i=0;i<l;++i){bytes[i]=bytes_as_string.charCodeAt(i)}return bytes});function siphashOfBytes(input,k0lo,k0hi,k1lo,k1hi,output){let v0lo=k0lo ^ 0x70736575;let v0hi=k0hi ^ 0x736f6d65;let v1lo=k1lo ^ 0x6e646f6d;let v1hi=k1hi ^ 0x646f7261;let v2lo=k0lo ^ 0x6e657261;let v2hi=k0hi ^ 0x6c796765;let v3lo=k1lo ^ 0x79746573;let v3hi=k1hi ^ 0x74656462;const inputLength=input.length;let inputI=0;const left=inputLength&0x7;let milo=0;let mihi=0;while(inputI<inputLength-left){u8ToU64le(inputI,inputI+8);v3lo ^=milo;v3hi ^=mihi;siphashCompress();v0lo ^=milo;v0hi ^=mihi;inputI+=8}u8ToU64le(inputI,inputI+left);const blo=milo;const bhi=((inputLength&0xff)<<24)|mihi;v3lo ^=blo;v3hi ^=bhi;siphashCompress();v0lo ^=blo;v0hi ^=bhi;v2lo ^=0xff;siphashCompress();siphashCompress();siphashCompress();output[7]=(v0lo ^ v1lo ^ v2lo ^ v3lo)&0xff;output[6]=(v0lo ^ v1lo ^ v2lo ^ v3lo)>>>8;output[5]=(v0lo ^ v1lo ^ v2lo ^ v3lo)>>>16;output[4]=(v0lo ^ v1lo ^ v2lo ^ v3lo)>>>24;output[3]=(v0hi ^ v1hi ^ v2hi ^ v3hi)&0xff;output[2]=(v0hi ^ v1hi ^ v2hi ^ v3hi)>>>8;output[1]=(v0hi ^ v1hi ^ v2hi ^ v3hi)>>>16;output[0]=(v0hi ^ v1hi ^ v2hi ^ v3hi)>>>24;function u8ToU64le(offset,length){const n0=offset<length?input[offset]&0xff:0;const n1=offset+1<length?input[offset+1]&0xff:0;const n2=offset+2<length?input[offset+2]&0xff:0;const n3=offset+3<length?input[offset+3]&0xff:0;const n4=offset+4<length?input[offset+4]&0xff:0;const n5=offset+5<length?input[offset+5]&0xff:0;const n6=offset+6<length?input[offset+6]&0xff:0;const n7=offset+7<length?input[offset+7]&0xff:0;milo=n0|(n1<<8)|(n2<<16)|(n3<<24);mihi=n4|(n5<<8)|(n6<<16)|(n7<<24)}function siphashCompress(){v0hi=(v0hi+v1hi+(((v0lo>>>0)+(v1lo>>>0)>0xffffffff)?1:0))|0;v0lo=(v0lo+v1lo)|0;let v1lo_=v1lo;let v1hi_=v1hi;v1lo=(v1lo_<<13)|(v1hi_>>>19);v1hi=(v1hi_<<13)|(v1lo_>>>19);v1lo ^=v0lo;v1hi ^=v0hi;const v0lo_=v0lo;const v0hi_=v0hi;v0lo=v0hi_;v0hi=v0lo_;v2hi=(v2hi+v3hi+(((v2lo>>>0)+(v3lo>>>0)>0xffffffff)?1:0))|0;v2lo=(v2lo+v3lo)|0;let v3lo_=v3lo;let v3hi_=v3hi;v3lo=(v3lo_<<16)|(v3hi_>>>16);v3hi=(v3hi_<<16)|(v3lo_>>>16);v3lo ^=v2lo;v3hi ^=v2hi;v0hi=(v0hi+v3hi+(((v0lo>>>0)+(v3lo>>>0)>0xffffffff)?1:0))|0;v0lo=(v0lo+v3lo)|0;v3lo_=v3lo;v3hi_=v3hi;v3lo=(v3lo_<<21)|(v3hi_>>>11);v3hi=(v3hi_<<21)|(v3lo_>>>11);v3lo ^=v0lo;v3hi ^=v0hi;v2hi=(v2hi+v1hi+(((v2lo>>>0)+(v1lo>>>0)>0xffffffff)?1:0))|0;v2lo=(v2lo+v1lo)|0;v1lo_=v1lo;v1hi_=v1hi;v1lo=(v1lo_<<17)|(v1hi_>>>15);v1hi=(v1hi_<<17)|(v1lo_>>>15);v1lo ^=v2lo;v1hi ^=v2hi;const v2lo_=v2lo;const v2hi_=v2hi;v2lo=v2hi_;v2hi=v2lo_}}function bigUint64ToShortHex(uint64){const n0=Number((uint64>>44n)&0xfn);const n1=Number((uint64>>40n)&0xfn);const n2=Number((uint64>>36n)&0xfn);const n3=Number((uint64>>32n)&0xfn);const n4=Number((uint64>>28n)&0xfn);const n5=Number((uint64>>24n)&0xfn);const n6=Number((uint64>>20n)&0xfn);const n7=Number((uint64>>16n)&0xfn);const n8=Number((uint64>>12n)&0xfn);const n9=Number((uint64>>8n)&0xfn);const n10=Number((uint64>>4n)&0xfn);const n11=Number(uint64&0xfn);const tbl=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f",];return(tbl[n0]+tbl[n1]+tbl[n2]+tbl[n3]+tbl[n4]+tbl[n5]+tbl[n6]+tbl[n7]+tbl[n8]+tbl[n9]+tbl[n10]+tbl[n11])}class ParametricDescription{constructor(w,n,minErrors){this.w=w;this.n=n;this.minErrors=minErrors}isAccept(absState){const state=Math.floor(absState/(this.w+1));const offset=absState%(this.w+1);return this.w-offset+this.minErrors[state]<=this.n}getPosition(absState){return absState%(this.w+1)}getVector(name,charCode,pos,end){let vector=0;for(let i=pos;i<end;i+=1){vector=vector<<1;if(name[i]===charCode){vector|=1}}return vector}unpack(data,index,bitsPerValue){const bitLoc=(bitsPerValue*index);const dataLoc=bitLoc>>5;const bitStart=bitLoc&31;if(bitStart+bitsPerValue<=32){return((data[dataLoc]>>bitStart)&this.MASKS[bitsPerValue-1])}else{const part=32-bitStart;return ~~(((data[dataLoc]>>bitStart)&this.MASKS[part-1])+((data[1+dataLoc]&this.MASKS[bitsPerValue-part-1])<<part))}}}ParametricDescription.prototype.MASKS=new Int32Array([0x1,0x3,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3F,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF,0xFFFFFFFF,]);class Lev2TParametricDescription extends ParametricDescription{transition(absState,position,vector){let state=Math.floor(absState/(this.w+1));let offset=absState%(this.w+1);if(position===this.w){if(state<3){const loc=Math.imul(vector,3)+state;offset+=this.unpack(this.offsetIncrs0,loc,1);state=this.unpack(this.toStates0,loc,2)-1}}else if(position===this.w-1){if(state<5){const loc=Math.imul(vector,5)+state;offset+=this.unpack(this.offsetIncrs1,loc,1);state=this.unpack(this.toStates1,loc,3)-1}}else if(position===this.w-2){if(state<13){const loc=Math.imul(vector,13)+state;offset+=this.unpack(this.offsetIncrs2,loc,2);state=this.unpack(this.toStates2,loc,4)-1}}else if(position===this.w-3){if(state<28){const loc=Math.imul(vector,28)+state;offset+=this.unpack(this.offsetIncrs3,loc,2);state=this.unpack(this.toStates3,loc,5)-1}}else if(position===this.w-4){if(state<45){const loc=Math.imul(vector,45)+state;offset+=this.unpack(this.offsetIncrs4,loc,3);state=this.unpack(this.toStates4,loc,6)-1}}else{if(state<45){const loc=Math.imul(vector,45)+state;offset+=this.unpack(this.offsetIncrs5,loc,3);state=this.unpack(this.toStates5,loc,6)-1}}if(state===-1){return-1}else{return Math.imul(state,this.w+1)+offset}}constructor(w){super(w,2,new Int32Array([0,1,2,0,1,-1,0,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-2,-1,-1,-2,-1,-2,-1,-1,-1,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,]))}}Lev2TParametricDescription.prototype.toStates0=new Int32Array([0xe,]);Lev2TParametricDescription.prototype.offsetIncrs0=new Int32Array([0x0,]);Lev2TParametricDescription.prototype.toStates1=new Int32Array([0x1a688a2c,]);Lev2TParametricDescription.prototype.offsetIncrs1=new Int32Array([0x3e0,]);Lev2TParametricDescription.prototype.toStates2=new Int32Array([0x70707054,0xdc07035,0x3dd3a3a,0x2323213a,0x15435223,0x22545432,0x5435,]);Lev2TParametricDescription.prototype.offsetIncrs2=new Int32Array([0x80000,0x55582088,0x55555555,0x55,]);Lev2TParametricDescription.prototype.toStates3=new Int32Array([0x1c0380a4,0x700a570,0xca529c0,0x180a00,0xa80af180,0xc5498e60,0x5a546398,0x8c4300e8,0xac18c601,0xd8d43501,0x863500ad,0x51976d6a,0x8ca0180a,0xc3501ac2,0xb0c5be16,0x76dda8a5,0x18c4519,0xc41294a,0xe248d231,0x1086520c,0xce31ac42,0x13946358,0x2d0348c4,0x6732d494,0x1ad224a5,0xd635ad4b,0x520c4139,0xce24948,0x22110a52,0x58ce729d,0xc41394e3,0x941cc520,0x90e732d4,0x4729d224,0x39ce35ad,]);Lev2TParametricDescription.prototype.offsetIncrs3=new Int32Array([0x80000,0xc0c830,0x300f3c30,0x2200fcff,0xcaa00a08,0x3c2200a8,0xa8fea00a,0x55555555,0x55555555,0x55555555,0x55555555,0x55555555,0x55555555,0x55555555,]);Lev2TParametricDescription.prototype.toStates4=new Int32Array([0x801c0144,0x1453803,0x14700038,0xc0005145,0x1401,0x14,0x140000,0x0,0x510000,0x6301f007,0x301f00d1,0xa186178,0xc20ca0c3,0xc20c30,0xc30030c,0xc00c00cd,0xf0c00c30,0x4c054014,0xc30944c3,0x55150c34,0x8300550,0x430c0143,0x50c31,0xc30850c,0xc3143000,0x50053c50,0x5130d301,0x850d30c2,0x30a08608,0xc214414,0x43142145,0x21450031,0x1400c314,0x4c143145,0x32832803,0x28014d6c,0xcd34a0c3,0x1c50c76,0x1c314014,0x430c30c3,0x1431,0xc300500,0xca00d303,0xd36d0e40,0x90b0e400,0xcb2abb2c,0x70c20ca1,0x2c32ca2c,0xcd2c70cb,0x31c00c00,0x34c2c32c,0x5583280,0x558309b7,0x6cd6ca14,0x430850c7,0x51c51401,0x1430c714,0xc3087,0x71451450,0xca00d30,0xc26dc156,0xb9071560,0x1cb2abb2,0xc70c2144,0xb1c51ca1,0x1421c70c,0xc51c00c3,0x30811c51,0x24324308,0xc51031c2,0x70820820,0x5c33830d,0xc33850c3,0x30c30c30,0xc30c31c,0x451450c3,0x20c20c20,0xda0920d,0x5145914f,0x36596114,0x51965865,0xd9643653,0x365a6590,0x51964364,0x43081505,0x920b2032,0x2c718b28,0xd7242249,0x35cb28b0,0x2cb3872c,0x972c30d7,0xb0c32cb2,0x4e1c75c,0xc80c90c2,0x62ca2482,0x4504171c,0xd65d9610,0x33976585,0xd95cb5d,0x4b5ca5d7,0x73975c36,0x10308138,0xc2245105,0x41451031,0x14e24208,0xc35c3387,0x51453851,0x1c51c514,0xc70c30c3,0x20451450,0x14f1440c,0x4f0da092,0x4513d41,0x6533944d,0x1350e658,0xe1545055,0x64365a50,0x5519383,0x51030815,0x28920718,0x441c718b,0x714e2422,0x1c35cb28,0x4e1c7387,0xb28e1c51,0x5c70c32c,0xc204e1c7,0x81c61440,0x1c62ca24,0xd04503ce,0x85d63944,0x39338e65,0x8e154387,0x364b5ca3,0x38739738,]);Lev2TParametricDescription.prototype.offsetIncrs4=new Int32Array([0x10000000,0xc00000,0x60061,0x400,0x0,0x80010008,0x249248a4,0x8229048,0x2092,0x6c3603,0xb61b6c30,0x6db6036d,0xdb6c0,0x361b0180,0x91b72000,0xdb11b71b,0x6db6236,0x1008200,0x12480012,0x24924906,0x48200049,0x80410002,0x24000900,0x4924a489,0x10822492,0x20800125,0x48360,0x9241b692,0x6da4924,0x40009268,0x241b010,0x291b4900,0x6d249249,0x49493423,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x2492,]);Lev2TParametricDescription.prototype.toStates5=new Int32Array([0x801c0144,0x1453803,0x14700038,0xc0005145,0x1401,0x14,0x140000,0x0,0x510000,0x4e00e007,0xe0051,0x3451451c,0xd015000,0x30cd0000,0xc30c30c,0xc30c30d4,0x40c30c30,0x7c01c014,0xc03458c0,0x185e0c07,0x2830c286,0x830c3083,0xc30030,0x33430c,0x30c3003,0x70051030,0x16301f00,0x8301f00d,0x30a18617,0xc20ca0c,0x431420c3,0xb1450c51,0x14314315,0x4f143145,0x34c05401,0x4c30944c,0x55150c3,0x30830055,0x1430c014,0xc00050c3,0xc30850,0xc314300,0x150053c5,0x25130d30,0x5430d30c,0xc0354154,0x300d0c90,0x1cb2cd0c,0xc91cb0c3,0x72c30cb2,0x14f1cb2c,0xc34c0540,0x34c30944,0x82182214,0x851050c2,0x50851430,0x1400c50c,0x30c5085,0x50c51450,0x150053c,0xc25130d3,0x8850d30,0x1430a086,0x450c2144,0x51cb1c21,0x1c91c70c,0xc71c314b,0x34c1cb1,0x6c328328,0xc328014d,0x76cd34a0,0x1401c50c,0xc31c3140,0x31430c30,0x14,0x30c3005,0xa0ca00d3,0x535b0c,0x4d2830ca,0x514369b3,0xc500d01,0x5965965a,0x30d46546,0x6435030c,0x8034c659,0xdb439032,0x2c390034,0xcaaecb24,0x30832872,0xcb28b1c,0x4b1c32cb,0x70030033,0x30b0cb0c,0xe40ca00d,0x400d36d0,0xb2c90b0e,0xca1cb2ab,0xa2c70c20,0x6575d95c,0x4315b5ce,0x95c53831,0x28034c5d,0x9b705583,0xa1455830,0xc76cd6c,0x40143085,0x71451c51,0x871430c,0x450000c3,0xd3071451,0x1560ca00,0x560c26dc,0xb35b2851,0xc914369,0x1a14500d,0x46593945,0xcb2c939,0x94507503,0x328034c3,0x9b70558,0xe41c5583,0x72caaeca,0x1c308510,0xc7147287,0x50871c32,0x1470030c,0xd307147,0xc1560ca0,0x1560c26d,0xabb2b907,0x21441cb2,0x38a1c70c,0x8e657394,0x314b1c93,0x39438738,0x43083081,0x31c22432,0x820c510,0x830d7082,0x50c35c33,0xc30c338,0xc31c30c3,0x50c30c30,0xc204514,0x890c90c2,0x31440c70,0xa8208208,0xea0df0c3,0x8a231430,0xa28a28a2,0x28a28a1e,0x1861868a,0x48308308,0xc3682483,0x14516453,0x4d965845,0xd4659619,0x36590d94,0xd969964,0x546590d9,0x20c20541,0x920d20c,0x5914f0da,0x96114514,0x65865365,0xe89d3519,0x99e7a279,0x9e89e89e,0x81821827,0xb2032430,0x18b28920,0x422492c7,0xb28b0d72,0x3872c35c,0xc30d72cb,0x32cb2972,0x1c75cb0c,0xc90c204e,0xa2482c80,0x24b1c62c,0xc3a89089,0xb0ea2e42,0x9669a31c,0xa4966a28,0x59a8a269,0x8175e7a,0xb203243,0x718b2892,0x4114105c,0x17597658,0x74ce5d96,0x5c36572d,0xd92d7297,0xe1ce5d70,0xc90c204,0xca2482c8,0x4171c62,0x5d961045,0x976585d6,0x79669533,0x964965a2,0x659689e6,0x308175e7,0x24510510,0x451031c2,0xe2420841,0x5c338714,0x453851c3,0x51c51451,0xc30c31c,0x451450c7,0x41440c20,0xc708914,0x82105144,0xf1c58c90,0x1470ea0d,0x61861863,0x8a1e85e8,0x8687a8a2,0x3081861,0x24853c51,0x5053c368,0x1341144f,0x96194ce5,0x1544d439,0x94385514,0xe0d90d96,0x5415464,0x4f1440c2,0xf0da0921,0x4513d414,0x533944d0,0x350e6586,0x86082181,0xe89e981d,0x18277689,0x10308182,0x89207185,0x41c718b2,0x14e24224,0xc35cb287,0xe1c73871,0x28e1c514,0xc70c32cb,0x204e1c75,0x1c61440c,0xc62ca248,0x90891071,0x2e41c58c,0xa31c70ea,0xe86175e7,0xa269a475,0x5e7a57a8,0x51030817,0x28920718,0xf38718b,0xe5134114,0x39961758,0xe1ce4ce,0x728e3855,0x5ce0d92d,0xc204e1ce,0x81c61440,0x1c62ca24,0xd04503ce,0x85d63944,0x75338e65,0x5d86075e,0x89e69647,0x75e76576,]);Lev2TParametricDescription.prototype.offsetIncrs5=new Int32Array([0x10000000,0xc00000,0x60061,0x400,0x0,0x60000008,0x6b003080,0xdb6ab6db,0x2db6,0x800400,0x49245240,0x11482412,0x104904,0x40020000,0x92292000,0xa4b25924,0x9649658,0xd80c000,0xdb0c001b,0x80db6d86,0x6db01b6d,0xc0600003,0x86000d86,0x6db6c36d,0xddadb6ed,0x300001b6,0x6c360,0xe37236e4,0x46db6236,0xdb6c,0x361b018,0xb91b7200,0x6dbb1b71,0x6db763,0x20100820,0x61248001,0x92492490,0x24820004,0x8041000,0x92400090,0x24924830,0x555b6a49,0x2080012,0x20004804,0x49252449,0x84112492,0x4000928,0x240201,0x92922490,0x58924924,0x49456,0x120d8082,0x6da4800,0x69249249,0x249a01b,0x6c04100,0x6d240009,0x92492483,0x24d5adb4,0x60208001,0x92000483,0x24925236,0x6846da49,0x10400092,0x241b0,0x49291b49,0x636d2492,0x92494935,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,0x49249249,0x92492492,0x24924924,]);class Lev1TParametricDescription extends ParametricDescription{transition(absState,position,vector){let state=Math.floor(absState/(this.w+1));let offset=absState%(this.w+1);if(position===this.w){if(state<2){const loc=Math.imul(vector,2)+state;offset+=this.unpack(this.offsetIncrs0,loc,1);state=this.unpack(this.toStates0,loc,2)-1}}else if(position===this.w-1){if(state<3){const loc=Math.imul(vector,3)+state;offset+=this.unpack(this.offsetIncrs1,loc,1);state=this.unpack(this.toStates1,loc,2)-1}}else if(position===this.w-2){if(state<6){const loc=Math.imul(vector,6)+state;offset+=this.unpack(this.offsetIncrs2,loc,2);state=this.unpack(this.toStates2,loc,3)-1}}else{if(state<6){const loc=Math.imul(vector,6)+state;offset+=this.unpack(this.offsetIncrs3,loc,2);state=this.unpack(this.toStates3,loc,3)-1}}if(state===-1){return-1}else{return Math.imul(state,this.w+1)+offset}}constructor(w){super(w,1,new Int32Array([0,1,0,-1,-1,-1]))}}Lev1TParametricDescription.prototype.toStates0=new Int32Array([0x2,]);Lev1TParametricDescription.prototype.offsetIncrs0=new Int32Array([0x0,]);Lev1TParametricDescription.prototype.toStates1=new Int32Array([0xa43,]);Lev1TParametricDescription.prototype.offsetIncrs1=new Int32Array([0x38,]);Lev1TParametricDescription.prototype.toStates2=new Int32Array([0x12180003,0xb45a4914,0x69,]);Lev1TParametricDescription.prototype.offsetIncrs2=new Int32Array([0x558a0000,0x5555,]);Lev1TParametricDescription.prototype.toStates3=new Int32Array([0x900c0003,0xa1904864,0x45a49169,0x5a6d196a,0x9634,]);Lev1TParametricDescription.prototype.offsetIncrs3=new Int32Array([0xa0fc0000,0x5555ba08,0x55555555,])